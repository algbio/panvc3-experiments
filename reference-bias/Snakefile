# Copyright (c) Tuukka Norri 2023
# Licenced under the MIT licence.

# vim: syntax=snakefile

REFERENCE_FA					= "../reference/hs37d5.fa"
TRUTH							= "../known-variants/HG001_GRCh37_1_22_v4.2.1_benchmark.vcf"
KNOWN_VARIANTS_PREFIX			= "../known-variants/ALL.chr"
KNOWN_VARIANTS_SUFFIX			= ".phase3_shapeit2_mvncall_integrated_v5b.20130502.genotypes.vcf.gz"
SAMPLE_ID						= "HG001"
CHROMOSOMES						= ['1']
ALL_CHROMOSOMES					= ['1'] # For generating equivalent seeds when changing CHROMOSOMES
KNOWN_VARIANTS_REMOVED_SAMPLES	= ["NA12878"]
CONFIDENT_REGIONS				= "../known-variants/HG001_GRCh37_1_22_v4.2.1_benchmark.bed"

MEM_GB							= 168

READS_1							= f"reads/{SAMPLE_ID}.p1.fq.gz"
READS_2							= f"reads/{SAMPLE_ID}.p2.fq.gz"

WORKFLOWS = [
	"bowtie2",
	"vg-map",
	"vg-giraffe",
	"panvc3-bowtie2-f14-d25.mapq-recalculated",
	"panvc3-bowtie2-f14-d25.max-mapq",
	"panvc3-bowtie2-f25-d50.mapq-recalculated",
	"panvc3-bowtie2-f25-d50.max-mapq"
]

BOWTIE2_CONFIG = {
	"alignment_id":								SAMPLE_ID,
	"reference":								REFERENCE_FA,
	"reads_1":									READS_1,
	"reads_2":									READS_2
}

PANVC3_CONFIG = {
	"alignment_id":								SAMPLE_ID,
	"reference":								REFERENCE_FA,
	"chromosomes":								CHROMOSOMES,
	"known_variants_prefix":					"input/known-variants.",
	"known_variants_suffix":					".vcf",
	"reads_1":									READS_1,
	"reads_2":									READS_2,
	"panvc3_conda_environment_path":			None,
	"vcf2multialign_conda_environment_path":	None
}

VG_CONFIG = {
	"alignment_id":								SAMPLE_ID,
	"reference":								REFERENCE_FA,
	"known_variants":							"input/known-variants.1.vcf.gz",
	"reads_1":									READS_1,
	"reads_2":									READS_2,
	"mem_gb":									MEM_GB
}


def none_if_empty(x):
	return x if bool(x) else None


wildcard_constraints:
	sample_id	= r"[^.]+"


rule all:
	input:
		reference_bias			= expand("reference-bias/{sample_id}.{wf}.{chromosome}.{regions}.mc{mc}.txt", sample_id = SAMPLE_ID, wf = WORKFLOWS, chromosome = CHROMOSOMES, regions = ["all", "confident"], mc = [1, 5, 10, 15, 20, 25]),
		precision_and_recall	= expand("alignment-precision-recall/{sample_id}.{wf}.d{dist}.tsv", sample_id = SAMPLE_ID, wf = WORKFLOWS, dist = [0, 5, 10, 20, 30])


rule alignments:
	input:	expand("alignments/{sample_id}.{wf}.bam", sample_id = SAMPLE_ID, wf = WORKFLOWS)


rule precision_recall_alignments:
	input:	expand("alignments/{sample_id}.{wf}.qname-sorted.bam", sample_id = SAMPLE_ID, wf = WORKFLOWS)


rule supporting_read_counts:
	input:	expand("supporting-reads-counts/{sample_id}.{wf}.{chromosome}.{regions}.txt.gz", sample_id = SAMPLE_ID, wf = WORKFLOWS, chromosome = CHROMOSOMES, regions = ["all", "confident"])


module common_rules:
	snakefile:	"../workflow/rules/common.smk"

use rule * from common_rules as common_*


module bowtie2_workflow:
	snakefile:	"../workflow/rules/bowtie2.smk"
	config:		BOWTIE2_CONFIG

use rule * from bowtie2_workflow as bowtie2_*


module panvc3_workflow:
	snakefile:	"../workflow/rules/panvc3.smk"
	config:		PANVC3_CONFIG

use rule * from panvc3_workflow as panvc3_*


module vg_workflow:
	snakefile:	"../workflow/rules/vg.smk"
	config:		VG_CONFIG

use rule * from vg_workflow as vg_*


rule remove_sample_from_known_variants:
	message:			"Removing the tested sample from known variants"
	conda:				"../workflow/environments/bcftools.yaml"
	input:				expand(f"{KNOWN_VARIANTS_PREFIX}{{chromosome}}{KNOWN_VARIANTS_SUFFIX}", chromosome = CHROMOSOMES)
	output:				"input/known-variants.{chromosome}.vcf"
	params:
		removed_samples	= lambda _: ",".join(map(lambda x: f"^{x}", KNOWN_VARIANTS_REMOVED_SAMPLES))
	shell:				"bcftools view -s {params.removed_samples} -O v -o {output} {input}"


rule filter_heterozygous_variants_from_truth:
	message:		"Filtering heterozygous variants from the truth"
	conda:			none_if_empty(config.get('vcf2multialign_conda_environment_path'))
	priority:		100
	input:	
		truth		= TRUTH
	output:			"input/tested-variants.{chromosome}.vcf"
	shell:			"vcfcat"
					" --input={input.truth}"
					" --output={output}"
					" --chromosome={wildcards.chromosome}"
					" --zygosity=1"
					" --replace-missing-id=unknown-"
					" --genotype-field=GT"
					" --omit-info"
					" --skip-invalid"


rule generate_predicted_sequences:
	message:		"Generating predicted haplotype sequences"
	conda:			none_if_empty(config.get('vcf2multialign_conda_environment_path'))
	priority:		100
	input:
		reference	= REFERENCE_FA,
		variants	= "input/tested-variants.{chromosome}.vcf"
	output:
		haplotype_1	= "input/{chromosome}.{sample_id}.1.fa",
		haplotype_2	= "input/{chromosome}.{sample_id}.2.fa",
		overlaps	= "input/overlaps.{chromosome}.{sample_id}.tsv"
	shell:			"cd input && vcf2multialign"
					" --haplotypes"
					" --input-reference=../{input.reference}"
					" --reference-sequence={wildcards.chromosome}"
					" --input-variants=../{input.variants}"
					" --chromosome={wildcards.chromosome}"
					" --dst-chromosome={wildcards.chromosome}"
					" --output-sequences-separate"
					" --separate-output-format=A2M"
					" --output-overlaps=overlaps.{wildcards.chromosome}.tsv"
					" --omit-reference"
					" --unaligned"


rule generate_predicated_a2m:
	message:        "Generating MSA of the predicted sequences"
	conda:			none_if_empty(config.get('vcf2multialign_conda_environment_path'))
	input:
		reference	= REFERENCE_FA,
		variants	= "input/tested-variants.{chromosome}.vcf"
	output:
		msa			= "msa-index/truth.{chromosome}.a2m.gz",
		overlaps	= "msa-index/overlaps.{chromosome}.tsv"
	shell:			"vcf2multialign"
					" --haplotypes"
					" --input-reference={input.reference}"
					" --reference-sequence={wildcards.chromosome}"
					" --input-variants={input.variants}"
					" --chromosome={wildcards.chromosome}"
					" --dst-chromosome={wildcards.chromosome}"
					" --output-sequences-a2m={output.msa}"
					" --output-overlaps={output.overlaps}"
					" --pipe=../workflow/scripts/run-gzip.sh"


rule combine_predicted_a2m:
	message:		"Combining the MSAs of the predicted sequences"
	input:			expand("msa-index/truth.{chromosome}.a2m.gz", chromosome = CHROMOSOMES)
	output:			"msa-index/truth.a2m.gz"
	shell:			"cat {input} > {output}"


rule index_msa:
	# FIXME: conda
	message:		"Building the MSA index"
	input:			"msa-index/truth.a2m.gz"
	output:			"msa-index/truth.dat"
	shell:			"panvc3_index_msa"
					" --build-index"
					" --sequences={input}"
					" --msa-index-output={output}"
					" --pipe-input='gzip -d -c'"


rule generate_reads:
	message:		"Generating reads"
	conda:			"../workflow/environments/mason.yaml"
	threads:		workflow.cores
	input:
		reference	= "input/{chromosome}.{sample_id}.{chr_copy}.fa"
	output:
		temp_dir	= temp(directory("temp/mason/temp.{sample_id}.{chromosome}.s{chr_copy}")),
		alignments	= "reads/{sample_id}.{chromosome}.s{chr_copy}.bam",
		reads_1		= "reads/{sample_id}.{chromosome}.s{chr_copy}.p1.fq.gz",
		reads_2		= "reads/{sample_id}.{chromosome}.s{chr_copy}.p2.fq.gz"
	params:
		chr_idx		= lambda wildcards: ALL_CHROMOSOMES.index(wildcards.chromosome)
	shell:			"mkdir -p {output.temp_dir} && TMPDIR={output.temp_dir} mason_simulator"
					" --verbose"
					" --seed $((21 + {wildcards.chr_copy} + {params.chr_idx}))"
					" --read-name-prefix simulated.s{wildcards.chr_copy}."
					" --num-threads {threads}"
					" --num-fragments 30000000"
					" --out {output.reads_1}"
					" --out-right {output.reads_2}"
					" --out-alignment {output.alignments}"
					" --input-reference {input.reference}"
					" --seq-technology illumina"
					" --illumina-read-length 101"


rule concatenate_reads:
	message:		"Concatenating reads"
	input:			expand("reads/{{sample_id}}.{chromosome}.s{chr_copy}.p{{pair}}.fq.gz", chromosome = CHROMOSOMES, chr_copy = [1, 2])
	output:			"reads/{sample_id}.p{pair}.fq.gz"
	shell:			"cat {input.reads_1} {input.reads_2} > {output}"


# samtools cat requires identical headers while merge rewrites the records, so we use the latter.
rule merge_aligned:
	message:		"Merging generated alignments"
	conda:			"../workflow/environments/samtools.yaml"
	threads:		8
	input:			expand("reads/{{sample_id}}.{chromosome}.s{chr_copy}.sorted.bam", chromosome = CHROMOSOMES, chr_copy = [1, 2])
	output:			"reads/{sample_id}.sorted.bam"
	shell:			"samtools merge -@ {threads} -O BAM -o {output} {input}"


rule reheader_aligned:
	message:		"Rewriting the header of the generated alignments"
	conda:			"../workflow/environments/biopython.yaml"
	input:			
		alignments	= "reads/{sample_id}.sorted.bam",
		rnames		= "reference-mapping-truth.tsv"
	output:			"reads/{sample_id}.rh.sorted.bam"
	shell:			"samtools reheader -c 'python3 ../workflow/scripts/replace_sam_rname_header.py {input.rnames}' {input.alignments} > {output}"


rule project_truth:
	# FIXME: conda
	threads:		workflow.cores
	input:			
		alignments		= "reads/{sample_id}.rh.sorted.bam",
		msa_index		= "msa-index/truth.dat",
		reference		= f"{REFERENCE_FA}.gz",
		reference_fai	= f"{REFERENCE_FA}.gz.fai",
		reference_gzi	= f"{REFERENCE_FA}.gz.gzi"
	output:			"reads/{sample_id}.projected.sam.gz"
	shell:			"panvc3_project_alignments"
					" --alignments={input.alignments}"
					" --msa-index={input.msa_index}"
					" --reference={input.reference}"
					" --reference-msa-id=REF"
					" --ref-id-separator=/"
					" | gzip > {output}"


rule count_supporting_reads:
	message:			"Counting supporting reads"
	conda:				none_if_empty(config.get('panvc3_conda_environment_path'))
	threads:			4
	input:				
		alignments		= "alignments/{sample_id}.{wf}.sorted.bam",
		variants		= "input/tested-variants.{chromosome}.vcf"
	output:				"supporting-reads-counts/{sample_id}.{wf}.{chromosome}.{regions}.txt.gz"
	params:
		regions_param	= lambda wildcards: f"--regions={CONFIDENT_REGIONS}" if "confident" == wildcards.regions else ""
	shell:				"set +o pipefail && samtools view -@ 2 {input.alignments} | panvc3_count_supporting_reads --vcf={input.variants} --chr={wildcards.chromosome} --contig={wildcards.chromosome} {params.regions_param} | gzip -c --verbose > {output}"


rule calculate_reference_bias:
	message:			"Calculating reference bias"
	conda:				none_if_empty(config.get('panvc3_conda_environment_path'))
	threads:			2
	input:				"supporting-reads-counts/{sample_id}.{wf}.{chromosome}.{regions}.txt.gz"
	output:				"reference-bias/{sample_id}.{wf}.{chromosome}.{regions}.mc{mc}.txt"
	shell:				"gunzip -c -k {input} | panvc3_calculate_reference_bias.py --min-coverage {wildcards.mc} > {output}"


rule calculate_precision_recall:
	message:			"Calculating alignment precision and recall"
	conda:				"../workflow/environments/biopython.yaml"
	input:
		truth			= "reads/{sample_id}.projected.qname-sorted.bam",
		tested			= "alignments/{sample_id}.{wf}.qname-sorted.bam"
	output:				"alignment-precision-recall/{sample_id}.{wf}.d{dist}.tsv"
	shell:				"python3"
						" ../workflow/scripts/alignment_position_precision_recall.py"
						" --distance-threshold {wildcards.dist}"
						" {input.truth}"
						" {input.tested}"
