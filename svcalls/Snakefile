# Copyright (c) Tuukka Norri 2023
# Licenced under the MIT licence.

# vim: syntax=snakefile


TRUTH				= "../truth/HG002_SVs_Tier1_v0.6.normalised.vcf.gz"
KNOWN_VARIANTS		= "../known-variants/ALL.chr1.phase3_shapeit2_mvncall_integrated_v5b.20130502.genotypes.vcf.gz"
READS_1				= "../reads/HG002_HiSeq30x_subsampled_R1.fastq.gz",
READS_2				= "../reads/HG002_HiSeq30x_subsampled_R2.fastq.gz"

REFERENCE_FA		= "../reference/hs37d5.fa"
REFERENCE_FAI		= "../reference/hs37d5.fa.fai"
REFERENCE_BWT		= "../reference/hs37d5.fa.bwt"
REFERENCE_GZ		= "../reference/hs37d5.fa.gz"

MEM_GB				= 168

# Remember to check the founder counts from vcf2multialign's output with each given distance.
WORKFLOWS = [
	("panvc3.bowtie2.f14.d25.mapq-recalculated",	"manta"),
	("panvc3.bowtie2.f14.d25.mapq-recalculated",	"gridss"),
	("panvc3.bowtie2.f14.d25.max-mapq",				"manta"),
	("panvc3.bowtie2.f14.d25.max-mapq",				"gridss"),
	("panvc3.bowtie2.f25.d50.mapq-recalculated",	"manta"),
	("panvc3.bowtie2.f25.d50.mapq-recalculated",	"gridss"),
	("panvc3.bowtie2.f25.d50.max-mapq",				"manta"),
	("panvc3.bowtie2.f25.d50.max-mapq",				"gridss"),
	("vg.giraffe",									"manta"),
	#("vg.giraffe",									"gridss"),
	("vg.map",										"manta"),
	#("vg.map",										"gridss"),
	("reference-flow.default",						"manta"),
	("reference-flow.default",						"gridss")
]


wildcard_constraints:
	filter			= "(all)|(pass)",
	vc_regions		= "(all)|(1)",
	eval_regions	= "(chr1)|(chr1_selected)",
	wg_wf			= "(giraffe)|(map)",
	panvc3_post		= "(projected)|(mapq-recalculated)"


def enclosing_dir(path):
	return path[:(path.rfind('/'))]


def last_component(path):
	return path[(1 + path.rfind('/')):]


rule all:
	input:		"summary.tsv"


rule summarise:
	input:		expand("truvari/{wf[0]}.{wf[1]}.{vc_regions}.{eval_regions}.{filter}/summary.json", wf = WORKFLOWS, vc_regions = ["all", "1"], eval_regions = ["chr1", "chr1_selected"], filter = ["all", "pass"])
	output:		"summary.tsv"
	shell:		"python3 summarise.py > {output}"


# Our cluster does not allow outgoing connections from the nodes, so here are the rules needed to install the environments.
rule install_bcftools:
	conda:		"../workflow/environments/bcftools.yaml"
	shell:		"echo 'Installed dependencies in bcftools.yaml'"


rule install_samtools:
	conda:		"../workflow/environments/samtools.yaml"
	shell:		"echo 'Installed dependencies in samtools.yaml'"


rule install_bwa:
	conda:		"../workflow/environments/bwa.yaml"
	shell:		"echo 'Installed dependencies in bwa.yaml'"


rule install_manta:
	conda:		"../workflow/environments/manta.yaml"
	shell:		"echo 'Installed dependencies in manta.yaml'"


rule install_gridss:
	conda:		"../workflow/environments/gridss.yaml"
	shell:		"echo 'Installed dependencies in gridss.yaml'"


rule install_truvari:
	conda:		"../workflow/environments/truvari.yaml"
	shell:		"echo 'Installed dependencies in truvari.yaml'"


rule index_fasta_fai:
	conda:		"../workflow/environments/samtools.yaml"
	input:		"{reference}.fa"
	output:		"{reference}.fa.fai"
	shell:		"samtools faidx {input}"


rule sort_bam:
	conda:		"../workflow/environments/samtools.yaml"
	threads:	16 # workflow.cores
	input:		"{alignments}.bam"
	output:		"{alignments}.sorted.bam"
	shell:		"../workflow/scripts/set-open-file-limit.sh samtools sort -@ {threads} -o {output} {input}"


rule sort_sam:
	conda:		"../workflow/environments/samtools.yaml"
	threads:	16 # workflow.cores
	input:		"{alignments}.sam"
	output:		"{alignments}.sorted.bam"
	shell:		"../workflow/scripts/set-open-file-limit.sh samtools sort -@ {threads} -o {output} {input}"


rule sort_sam_gz:
	conda:		"../workflow/environments/samtools.yaml"
	threads:	16 # workflow.cores
	input:		"{alignments}.sam.gz"
	output:		"{alignments}.sorted.bam"
	shell:		"../workflow/scripts/set-open-file-limit.sh samtools sort -@ {threads} -o {output} {input}"


rule index_bam:
	conda:		"../workflow/environments/samtools.yaml"
	threads:	16 # workflow.cores
	input:		"{alignments}.bam"
	output:		"{alignments}.bam.bai"
	shell:		"samtools index -@ {threads} {input}"


rule normalise_vcf_gz:
	conda:		"../workflow/environments/bcftools.yaml"
	input:		"{variants}.vcf.gz"
	output:		"{variants}.normalised.vcf.gz"
	shell:		"bcftools norm -m - -O z -o {output} {input}"


rule index_vcf_gz_csi:
	conda:		"../workflow/environments/bcftools.yaml"
	input:		"{variants}.vcf.gz"
	output:		"{variants}.vcf.gz.csi"
	shell:		"bcftools index {input}"


rule index_vcf_gz_tbi:
	conda:		"../workflow/environments/bcftools.yaml"
	input:		"{variants}.vcf.gz"
	output:		"{variants}.vcf.gz.tbi"
	shell:		"bcftools index -t {input}"


rule bwa_index:	# Needed by gridss
	conda:		"../workflow/environments/bwa.yaml"
	input:		"{reference}.fa"
	output:		multiext("{reference}.fa", ".amb", ".ann", ".bwt", ".pac", ".sa")
	shell:		"bwa index {input}"


configfile: "config/panvc3.yaml"

module panvc3_workflow:
	snakefile:	"../workflow/rules/panvc3.smk"
	config:		config["panvc3"]

use rule * from panvc3_workflow as panvc3_*

rule link_panvc3_alignments:
	input:	"panvc3/{alignments}.{panvc3_post}.sam.gz"
	output:	"panvc3/{alignments}.{panvc3_post}.all.sam.gz"
	params:
		dd	= lambda wildcards: enclosing_dir(wildcards.alignments)
		ff	= lambda wildcards: last_component(wildcards.alignments)
	shell:	"cd {params.dd} && ln -s {params.ff}.{panvc3_post}.sam.gz {params.ff}.{panvc3_post}.all.sam.gz"


# Enable when this is resolved: https://github.com/snakemake/snakemake/issues/2499
#configfile: "config/reference-flow.yaml"
#
#module reference_flow_workflow:
#	snakefile:	"lib/reference_flow/snakemake/Snakefile"
#	config: config["reference_flow"]
#
#use rule * from reference_flow_workflow as reference_flow_*
#
#use rule all from reference_flow_workflow as reference_flow_all with:
#	benchmark:	"benchmark/reference_flow"

## “.all.” needed for subsetting alignments for gridss.
rule reference_flow_run:
	threads:		workflow.cores
	benchmark:		"benchmark/run_reference_flow_sp"
	input:
		reads_1		= READS_1,
		reads_2		= READS_2
	output:			"reference-flow/run/experiments/NA24385/thrds0_S1_b1000_ld1/chr1-refflow-10-thrds0_S1_b1000_ld1-liftover.all.sam"
	shell:			"snakemake --printshellcmds --cores {threads} --snakefile lib/reference_flow/snakemake/Snakefile --use-conda --conda-prefix ../conda-env --configfile config/reference-flow-sp.yaml -- && pushd reference-flow/run/experiments/NA24385/thrds0_S1_b1000_ld1 && ln -s chr1-refflow-10-thrds0_S1_b1000_ld1-liftover.sam chr1-refflow-10-thrds0_S1_b1000_ld1-liftover.all.sam"


rule vg_index:
	conda:				"../workflow/environments/vg.yaml"
	threads:			workflow.cores
	input:
		reference		= REFERENCE_FA,
		known_variants	= KNOWN_VARIANTS
	output:				multiext("vg/map/index", ".gcsa", ".gcsa.lcp", ".xg")
	benchmark:			"benchmark/vg_index"
	shell:
		"vg autoindex --threads {threads} --workflow map --tmp-dir temp --target-mem {MEM_GB}G -r {input.reference} -v {input.known_variants} -p vg/map/index"
		

rule vg_index_giraffe:
	conda:				"../workflow/environments/vg.yaml"
	threads:			workflow.cores
	input:
		reference		= REFERENCE_FA,
		known_variants	= KNOWN_VARIANTS
	output:				"vg/giraffe/index.giraffe.gbz"
	benchmark:	 		"benchmark/vg_index_giraffe"
	shell:
		"vg autoindex --threads {threads} --workflow giraffe --tmp-dir temp --target-mem {MEM_GB}G -r {input.reference} -v {input.known_variants} -p vg/giraffe/index"


rule vg_map:
	conda:				"../workflow/environments/vg.yaml"
	threads:			workflow.cores
	input:
		index_gcsa		= "vg/map/index.gcsa",
		index_gcsa_lcp	= "vg/map/index.gcsa.lcp",
		index_xg		= "vg/map/index.xg",
		reads_1			= READS_1,
		reads_2			= READS_2
	output:				"vg/mapped-reads.map.all.bam"
	benchmark:			"benchmark/vg_map"
	shell:
		"vg map --threads {threads} --fastq {input.reads_1} --fastq {input.reads_2} --base-name vg/map/index --surject-to bam > {output}"
	

rule vg_map_giraffe:
	conda:			"../workflow/environments/vg.yaml"
	threads:		workflow.cores
	input:
		index		= "vg/giraffe/index.giraffe.gbz",
		reads_1		= READS_1,
		reads_2		= READS_2
	output:			"vg/mapped-reads.giraffe.all.bam"
	benchmark:		"benchmark/vg_map_giraffe"
	shell:
		"vg giraffe --threads {threads} --gbz-name vg/giraffe/index.giraffe.gbz --minimizer-name vg/giraffe/index.min --dist-name vg/giraffe/index.dist --fastq-in {input.reads_1} --fastq-in {input.reads_2} -o BAM > {output}"


def manta_region_arg(wildcards):
	if 'all' == wildcards.vc_regions:
		return ""
	return f"--region={wildcards.vc_regions}"


rule manta_config_panvc3:
	conda:			"../workflow/environments/manta.yaml"
	input:
		reference	= REFERENCE_FA,
		alignments	= "panvc3/alignments/{aligner}/alignments.{panvc3_wf}.all.sorted.bam",
		index		= "panvc3/alignments/{aligner}/alignments.{panvc3_wf}.all.sorted.bam.bai"
	params:
		region_arg	= manta_region_arg
	output:			"manta/panvc3.{aligner}.{panvc3_wf}.{vc_regions}/runWorkflow.py"
	shell:			"configManta.py --runDir='manta/panvc3.{wildcards.aligner}.{wildcards.panvc3_wf}.{wildcards.vc_regions}' --referenceFasta='{input.reference}' --bam={input.alignments} {params.region_arg}"


rule manta_config_vg:
	conda:			"../workflow/environments/manta.yaml"
	input:
		reference	= REFERENCE_FA,
		alignments	= "vg/mapped-reads.{vg_wf}.all.sorted.bam",
		index		= "vg/mapped-reads.{vg_wf}.all.sorted.bam.bai"
	params:
		region_arg	= manta_region_arg
	output:			"manta/vg.{vg_wf}.{vc_regions}/runWorkflow.py"
	shell:			"configManta.py --runDir='manta/vg.{wildcards.vg_wf}.{wildcards.vc_regions}' --referenceFasta='{input.reference}' --bam={input.alignments} {params.region_arg}"


rule manta_config_reference_flow:
	conda:			"../workflow/environments/manta.yaml"
	input:
		reference	= REFERENCE_FA,
		alignments	= "reference-flow/run/experiments/NA24385/thrds0_S1_b1000_ld1/chr1-refflow-10-thrds0_S1_b1000_ld1-liftover.sorted.bam",
		index		= "reference-flow/run/experiments/NA24385/thrds0_S1_b1000_ld1/chr1-refflow-10-thrds0_S1_b1000_ld1-liftover.sorted.bam.bai"
	params:
		region_arg	= manta_region_arg
	output:			"manta/reference-flow.default.{vc_regions}/runWorkflow.py"
	shell:			"configManta.py --runDir='manta/reference-flow.default.{wildcards.vc_regions}' --referenceFasta='{input.reference}' --bam={input.alignments} {params.region_arg}"


rule manta_run:
	conda:			"../workflow/environments/manta.yaml"
	threads:		workflow.cores
	input:			"manta/{wf}/runWorkflow.py"
	output:			"manta/{wf}/results/variants/diploidSV.vcf.gz"
	shell:			"{input} -j {threads} -g {MEM_GB}"


rule gridss_subset_alignments:
	conda:			"../workflow/environments/gridss.yaml"
	threads:		workflow.cores
	input:
		alignments	= "{alignments}.all.sorted.bam",
		chrom		= "regions/chr{vc_regions}.bed"
	output:			"{alignments}.{vc_regions}.bam"
	shell:			"gridss_extract_overlapping_fragments --threads {threads} --targetbed {input.chrom} --output {output} {input.alignments}"


rule gridss_run_panvc3:
	conda:			"../workflow/environments/gridss.yaml"
	threads:		workflow.cores
	input:
		reference	= REFERENCE_FA,
		ref_fai		= REFERENCE_FAI,
		ref_bwt		= REFERENCE_BWT,
		alignments	= "panvc3/alignments/{aligner}/alignments.{panvc3_wf}.all.sorted.bam"
	output:			"gridss/panvc3.{aligner}.{panvc3_wf}.{vc_regions}.vcf.gz"
	shell:			"gridss --threads {threads} --workingdir work/gridss --reference {input.reference} --output {output} {input.alignments}"


rule gridss_run_vg:
	conda:			"../workflow/environments/gridss.yaml"
	threads:		workflow.cores
	input:
		reference	= REFERENCE_FA,
		ref_fai		= REFERENCE_FAI,
		ref_bwt		= REFERENCE_BWT,
		alignments	= "vg/mapped-reads.{vg_wf}.{vc_regions}.sorted.bam"
	output:			"gridss/vg.{vg_wf}.{vc_regions}.vcf.gz"
	shell:			"gridss --threads {threads} --workingdir work/gridss --reference {input.reference} --output {output} {input.alignments}"


rule gridss_run_reference_flow:
	conda:			"../workflow/environments/gridss.yaml"
	threads:		workflow.cores
	input:
		reference	= REFERENCE_FA,
		ref_fai		= REFERENCE_FAI,
		ref_bwt		= REFERENCE_BWT,
		alignments	= "reference-flow/run/experiments/NA24385/thrds0_S1_b1000_ld1/chr1-refflow-10-thrds0_S1_b1000_ld1-liftover.{vc_regions}.sorted.bam"
	output:			"gridss/reference-flow.default.{vc_regions}.vcf.gz"
	shell:			"gridss --threads {threads} --workingdir work/gridss --reference {input.reference} --output {output} {input.alignments}"


def truvari_dir_name(variant_caller):
	return lambda wildcards: f"truvari/{wildcards.wf}.{variant_caller}.{wildcards.vc_regions}.{wildcards.eval_regions}.{wildcards.filter}"


rule truvari_run_manta:
	conda:			"../workflow/environments/truvari.yaml"
	input:
		variants	= "manta/{wf}.{vc_regions}/results/variants/diploidSV.normalised.vcf.gz",
		index		= "manta/{wf}.{vc_regions}/results/variants/diploidSV.normalised.vcf.gz.tbi"
	output:			"truvari/{wf}.manta.{vc_regions}.{eval_regions}.{filter}/summary.json"
	params:
		truvari_dir	= truvari_dir_name("manta"),
		filter_arg	= lambda wildcards: "--passonly" if "pass" == wildcards.filter else ""
	shell:			"rmdir {params.truvari_dir} && truvari bench -b {TRUTH} -c {input.variants} -o {params.truvari_dir} --reference {REFERENCE_GZ} --includebed regions/{wildcards.eval_regions}.bed --sizemin 0 --sizefilt 0 {params.filter_arg}"


rule truvari_run_gridss:
	conda:			"../workflow/environments/truvari.yaml"
	input:
		variants	= "gridss/{wf}.{vc_regions}.normalised.vcf.gz",
		index		= "gridss/{wf}.{vc_regions}.normalised.vcf.gz.tbi"
	output:			"truvari/{wf}.gridss.{vc_regions}.{eval_regions}.{filter}/summary.json"
	params:
		truvari_dir	= truvari_dir_name("gridss"),
		filter_arg	= lambda wildcards: "--passonly" if "pass" == wildcards.filter else ""
	shell:			"rmdir {params.truvari_dir} && truvari bench -b {TRUTH} -c {input.variants} -o {params.truvari_dir} --reference {REFERENCE_GZ} --includebed regions/{wildcards.eval_regions}.bed --sizemin 0 --sizefilt 0 {params.filter_arg}"


ruleorder: sort_bam > sort_sam_gz > sort_sam
